======================================================================================================
                                                Vendor app
=======================================================================================================

1. First step is to create the app called vendor

2. Next step is to configure in app section of settings

class Vendor(models.Model):
    user = models.OneToOneField(User,related_name='user',on_delete=models.CASCADE)
    user_profile = models.OneToOneField(UserProfile,related_name='user',on_delete=models.CASCADE)
    vendor_name = models.CharField(max_length=50)
    vendor_license = models.ImageField(upload_to='/vendor/license')
    is_approved = models.BooleanField(default=False)
    created_at = models.DateTimeField(auto_now_add=True)
    modified_at = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.vendor_name


Here above for ImageField we didn't specify media path because we already configured it before in
settings

Next step is to go to admin.py and register our model there

admin.py
----------------------------------------------------------------------------------------------------
from django.contrib import admin
from vendor.models import Vendor
# Register your models here.

admin.site.register(Vendor)

Next step is to apply migrations

urls.py
----------------------------------------------------------------------------------------------------
setup registerVendor.html in urls.py

create method in views.py

def registerVendor(request):
    return render(request,'accounts/registerVendor.html')

create django model form for registering the vendors 

vendor/forms.py
--------------------------------------------------------------------------------------------------
from django import forms
from .models import Vendor
class VendorForm(forms.ModelForm):
    class Meta:
        model = Vendor
        fields = ['vendor_name','vendor_license']

Next step is to combine the two forms inorder to print the contents of form in registerVendor.html

In accounts/views.py write the following code
------------------------------------------------------------------------------------------------
def registerVendor(request):
    form = UserForm()
    v_form = VendorForm()

    context = {
        'form':form,
        'v_form':v_form
    }
    return render(request,'accounts/registerVendor.html', context=context)

Now in accounts/registerVendor.html file print the v_form fields and also 
put enctype="multipart/form-data" in <form> to upload files properly

vendor/models.py
--------------------------------------------------------------------------------------------
For Displaying contents in admin panel of vendor

class VendorAdmin(admin.ModelAdmin):
    list_display = ('user','vendor_name','is_approved','created_at')
    list_display_links = ('user','vendor_name')
admin.site.register(Vendor, VendorAdmin)


Implementing Login and Logout Features
-------------------------------------------------------------------------------------------------
go to accounts/urls.py

from django.urls import path
from . import views
urlpatterns = [
    path('registerUser/',views.registerUser, name='registerUser'),
    path('registerVendor/',views.registerVendor,name='registerVendor'),
    path('login/',views.login, name='login'),
    path('logout/',views.logout,name='logout'),
    path('dashboard/',views.dashboard,name='dashboard'),

]

go to views.py and add the functionalities

go to accounts create login.html

go to views.py implement login() functionalities

accounts/views.py
-------------------------------------------------------------------------------------------
def login(request):
    if request.method == "POST":
        email = request.POST['email']
        password = request.POST['password']
        user = auth.authenticate(request=request, email=email,password=password)
        
    return render(request, 'accounts/login.html')

auth.authenticate() returns user if they exist
--------------------------------------------------------------------------------------------
Preventing user from accessing login and registerUser urls after he logged in 
accounts/views/registerUser() and login() in both functions write this code
    if request.user.is_authenticated:
        messages.info(request, "You are already an existing user!")
        return redirect('dashboard')

Detecting the user whether it is customer or vendor and redirect customer to customer dashboard and
Vendor to vendor Dashboard

Go to accounts/models.py

write the following function 

    def get_role(self):
        if self.role == 1:
            user_role = 'Vendor'
        elif self.role == 2:
            user_role = 'Customer'
        return user_role

in dashboard.html write the following code 

<p>This is a {{user.get_role}}</p>

Next step is to detect the user this will help us to redirect to which dashboard whether it is 
custDashboard or VendorDashboard or admin 
go to accounts/urls.py create an patj 

path('myAccount/', views.myAccount, name='myAccount '),

now create an helper file utils.py it contains all the helper functions of our website

accounts/utils.py 
---------------------------------------------------------------------------------------------------
def detectUser(user):
    if user.role == 1:
        redirectUrl = 'vendorDashboard'
        return redirectUrl
    elif user.role == 2:
        redirectUrl = 'custDashboard'
        return redirectUrl
    elif user.role == None and user.is_superadmin:
        redirectUrl = '/admin'
        return redirectUrl

---------------------------------------------------------------------------------------------------

accounts/views.py 
-----------------
def myAccount(request):
    user = request.user
    redirectUrl = detectUser(user)
    return redirect(redirectUrl)

After creating this function we need to change the dashboard in navbar to myAccount url
specify this myAccount in both login() and registeruser() function in accounts/views 

Note: Whenver we are not logged and when we try to access the url through browser 
http://127.0.0.1:8000/accounts/myAccount/ then this raise an error called attribute error
because whenever we are using myAccount it means we are calling myAccount function and myAccount function
is only used at when user is send a request and it identifies whether he is an vendor or customer without
having any user information if we try to call this method by url path it raises inorder to avoid this
error we need to make sure that we have to call this method only at the time of the login 
for this we need to use decorator

from django.contrib.auth.decorators import login_required

@login_required(login_url='login',) --> it will send the user to the login page if he didnt login
def myAccount(request):
    user = request.user
    redirectUrl = detectUser(user)
    return redirect(redirectUrl)


------------------------------------------------------------------------------------------------
Restricting the customer from accessing vendor dashboard and vice versa


from django.contrib.auth.decorators import login_required, user_passes_test
from django.core.exceptions import PermissionDenied

#Restrict the vendor from accessing the customer dashboard 
def check_role_vendor(user):
    if user.role == 1:
        return True
    else:
        # This error comes from django.core.exceptions
        raise PermissionDenied("")


#  customer from accessing the vendors
def check_role_customer(user):
    if user.role ==2:
        return True
    else:
        raise PermissionDenied

-----------------------------------------------------------------------------------------
Implementing Custom Error templates in django like 403, 404 etc
just make a html page with error name in templates

ex: templates/includes/403.html